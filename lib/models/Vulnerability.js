'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Vulnerability;

var _util = require('../util.js');

var _background = require('../background.js');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Vulnerability(application) {
  this.application = application;
}

/**
 * updateVulnerabilities - updates the currenctly stored trace ids
 *
 * @param  {Object} tab Gives the state of the tab that was updated.
 * @return {void}
 */
Vulnerability.updateVulnerabilities = function (tab, app, credentialed) {
  var _this = this;

  // first remove old vulnerabilities since tab has updated or activated
  var evaluated = false; // used to send message only once
  if (!app) return;
  if (!evaluated) {
    chrome.tabs.sendMessage(tab.id, { action: _util.GATHER_FORMS_ACTION }, function (resp) {

      // NOTE: An undefined reponse usually occurrs only in dev, when a user navigates to a tab after reloading the extension and doesn't refresh the page.
      if (!resp) {
        (0, _util.updateTabBadge)(tab, "X", _util.CONTRAST_RED);
        // NOTE: Below is possibly dangerous if !resp even after reload
        // TODO: chrome.tabs.reload(tab.id)
        // return;
      }

      evaluated = true;

      if (resp && resp.formActions && resp.formActions.length > 0) {
        var formActions = resp.formActions;
        var traceUrls = [tab.url].concat(formActions);
        _this.evaluateVulnerabilities(credentialed, tab, traceUrls, app);
      } else {
        _this.evaluateVulnerabilities(credentialed, tab, [tab.url], app);
      }
    });
  }
};

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object}  tab            Gives the state of the current tab
 * @param  {Array}   traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function (hasCredentials, tab, traceUrls, application) {
  var isXHR = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if (isXHR) {
    console.log("trace urls for evaluateVulnerabilities when isXHR", traceUrls.length);
  }

  if (hasCredentials && !!traceUrls && traceUrls.length > 0) {

    if (!application) {
      (0, _util.updateTabBadge)(tab, _util.CONTRAST_CONFIGURE_TEXT, _util.CONTRAST_YELLOW);
      return null;
    }

    // generate an array of only pathnames
    var urlQueryString = (0, _util.generateTraceURLString)(traceUrls);

    this._getVulnerabilityTraces(urlQueryString, traceUrls, application, tab, isXHR);
  } else if (hasCredentials && !!traceUrls && traceUrls.length === 0) {
    (0, _util.updateTabBadge)(tab, "0", _util.CONTRAST_RED);
  } else {
    (0, _background.notifyUserToConfigure)(tab);
  }
};

Vulnerability._getVulnerabilityTraces = function (url, traceUrls, app, tab, isXHR) {
  var _this2 = this;

  (0, _util.getOrganizationVulnerabilityIds)(url, app.id).then(function (json) {
    if (!json) {
      throw new Error("Error getting json from app trace ids");
    } else if (json.traces.length === 0) {
      if (!chrome.runtime.lastError && !isXHR) {
        (0, _util.updateTabBadge)(tab, json.traces.length.toString(), _util.CONTRAST_RED);
      }
    } else if (!isXHR) {
      chrome.tabs.sendMessage(tab.id, {
        action: "HIGHLIGHT_VULNERABLE_FORMS",
        traceUrls: traceUrls
      });
      _this2.storeTraces(json.traces, tab);
    }

    // isXHR is true, content script requests that XHR requests get queried for vulnerabilities
    else {
        // reset XHR global request array to empty, now accepting new requests
        (0, _background.resetXHRRequests)();
        _this2.storeTraces(json.traces, tab);
      }
  }).catch(function (error) {
    console.log(error);
    (0, _util.updateTabBadge)(tab, "X", _util.CONTRAST_RED);
    throw new Error("Error getting organization vulnerability ids");
  });
};

/**
 * storeTraces - locals the trace ids of found vulnerabilities to storage
 * https://blog.lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795
 * https://stackoverflow.com/a/37576787/6410635
 *
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = function (foundTraces, tab) {
  var _this3 = this;

  // clean the traces array of empty strings which are falsey in JS and which will be there if a trace doesn't match a given URI
  var traces = foundTraces.filter(Boolean);
  console.log("traces before buildVulnerabilitiesArray", traces);
  this.buildVulnerabilitiesArray(traces).then(function (vulnerabilities) {
    console.log("buildVulnerabilitiesArray vulnerabilities", vulnerabilities);
    chrome.storage.local.get(_util.STORED_TRACES_KEY, function (currentTraces) {
      console.log("currentTraces", currentTraces);
      var storedTraces = _this3._handleCurrentTraces(currentTraces, vulnerabilities);
      console.log("storedTraces", storedTraces);
      console.log(_util.STORED_TRACES_KEY);
      // takes a callback with a result param but there's nothing to do with it and eslint doesn't like unused params or empty blocks
      chrome.storage.local.set(storedTraces, function () {
        chrome.storage.local.get(_util.STORED_TRACES_KEY, function (result) {
          // set tab badget to the length of traces in storage (can change)
          (0, _util.updateTabBadge)(tab, result[_util.STORED_TRACES_KEY].length.toString(), _util.CONTRAST_RED);
        });
      });
    });
  }).catch(function () {
    (0, _util.updateTabBadge)(tab, "X", _util.CONTRAST_RED);
  });
};

Vulnerability._handleCurrentTraces = function (currentTraces, vulnerabilities) {
  var parsed = [];
  if (currentTraces[_util.STORED_TRACES_KEY]) {
    parsed = currentTraces[_util.STORED_TRACES_KEY];
  }

  var storedTraces = {};
  var newVulns = parsed.concat(vulnerabilities);

  return _defineProperty({}, _util.STORED_TRACES_KEY, (0, _util.deDupeArray)(newVulns));
};

/**
 * buildVulnerabilitiesArray - builds an array of trace ids, retrieving previously stored ids and deduping
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @return {Promise} - a promise that resolves to an array of deduplicated trace ids
 */
Vulnerability.buildVulnerabilitiesArray = function (foundTraces) {
  var _this4 = this;

  return new Promise(function (resolve, reject) {

    // first check if there are already vulnerabilities in storage
    chrome.storage.local.get(_util.STORED_TRACES_KEY, function (result) {
      var results = void 0;

      // results have not been set yet so just pass on foundTraces
      if (!result[_util.STORED_TRACES_KEY] || !!result[_util.STORED_TRACES_KEY] && result[_util.STORED_TRACES_KEY].length === 0) {
        resolve((0, _util.deDupeArray)(foundTraces));
      } else {
        try {
          // add existing foundTraces to passed in array
          results = result[_util.STORED_TRACES_KEY];
          results = results.concat(foundTraces);
          resolve((0, _util.deDupeArray)(results));
        } catch (e) {
          // if this errors then remove all the vulnerabilities from storage and start over
          _this4.removeVulnerabilitiesFromStorage().then(function () {
            return resolve([]);
          });
        }
      }
      reject(new Error("Rejected buildVulnerabilitiesArray"));
    });
  });
};

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function () {
  return new Promise(function (resolve, reject) {
    chrome.storage.local.remove(_util.STORED_TRACES_KEY, function () {
      if (chrome.runtime.lastError) {
        reject(new Error(chrome.runtime.lastError));
      }

      resolve();
    });
  });
};