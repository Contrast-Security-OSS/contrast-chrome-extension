const chrome   = require('sinon-chrome/extensions');
const jsdom    = require("jsdom");
const testData = require("../testData")
const sinon    = require("sinon");
const chai     = require("chai");
const assert   = chai.assert;

const { JSDOM } = jsdom;

const {
  returnShortTraceData,
  returnShortTraceDataLowSeverity,
} = testData;

const vulnMethods = require('../../lib/vulnerabilityMethods')
let {
  renderListItem,
  populateVulnerabilitySection,
  getStorageVulnsAndRender,
  getShortVulnerabilities,
} = vulnMethods;

const util = require("../../lib/util.js");
let {
  setElementDisplay,
  setElementText,
  getVulnerabilityShort,
} = util;

/**
* Array.prototype.flatten - reduce multi-dimensional arrays to single dimension
*
* add the .flatten() method to Array instances
* the empty array is the initial value of the new array
*
* @return {Array}
*/
Array.prototype.flatten = function() {
  return this.reduce((newArray, val) => newArray.concat(val), []);
}


/**
* String.prototype.titleize - capitalize the first letter of each word in a string, regardless of special characters
* https://stackoverflow.com/a/6251509/6410635
* https://stackoverflow.com/a/196991/6410635
*
* @return {String} titleized string
*/
String.prototype.titleize = function() {
  return this.replace(/\b([a-z])/g, function(captured) {
    return captured.charAt(0).toUpperCase() + captured.substr(1).toLowerCase();
  });
}


describe('test how vulnerabilities are rendered to user', function() {

  // set jsdom document as node js global
  global.document = (new JSDOM(
    `<!DOCTYPE html><html><head></head><body></body></html>`
  )).window.document;

  const traces = ['this-is-a-trace', 'this-is-another-trace'];
  const teamserver_url = "url";
  const contrast_org_uuid = "uuid";
  const items = {
    teamserver_url,
    contrast_org_uuid,
  }

  const container = document.createElement('ul');
  const noVulns   = document.createElement('div');
  const vulnsOnPage = document.createElement('div');
  noVulns.setAttribute('id', 'no-vulnerabilities-found');
  vulnsOnPage.setAttribute('id', 'vulnerabilities-found-on-page');

  document.children[0].appendChild(container);
  document.body.appendChild(noVulns);
  document.body.appendChild(vulnsOnPage);

  container.setAttribute('id', 'vulnerabilities-found-on-page-list');
  container.style.display = 'none';

  let child;

  beforeEach(function() {
    global.chrome = chrome;

    noVulns.style.display = '';
    vulnsOnPage.style.display = '';

    if (!!container.children.length > 0) {
      container.children[0].parentNode.removeChild(container.children[0]);
    } else {
      renderListItem(returnShortTraceData, "teamserverURL", "org uuid");
      child = container.children[0];
    }
    chrome.runtime.sendMessage.flush();
  })

  afterEach(function() {
    if (!!container.children.length > 0) {
      container.children[0].parentNode.removeChild(container.children[0]);
    }
    chrome.flush();
    delete global.chrome;
  });

  it('renders a number of vulnerabilities equal to the number of traces provided', function() {
    assert.equal(container.children.length, 1);
    assert.equal(child.tagName, "LI");
    assert.equal(child.className, "list-group-item no-border vulnerability-li vuln-1");
    assert.equal(child.children.length, 2);
  });

  it('navigates to teamserver when a vulnerability is clicked', function() {
    const anchor  = child.getElementsByTagName('a')[0];
    anchor.click();
    assert.isTrue(chrome.tabs.create.calledOnce);
  });

  it('orders the rendered vulnerabilities by severity', function() {
    assert.equal(container.children.length, 1);
    renderListItem(returnShortTraceDataLowSeverity, "teamserverURL", "org-uuid")
    assert.equal(container.children.length, 2);

    const child1 = container.children[1];

    assert.ok(child.getElementsByTagName('img')[0].src.includes("critical"));
    assert.ok(child1.getElementsByTagName('img')[0].src.includes("low"));
  });

  it('requests stored traces from background', function() {
    getStorageVulnsAndRender({
      teamserver_url: "url",
      contrast_org_uuid: "uuid"
    });
    assert.ok(chrome.runtime.sendMessage.calledOnce);
  });

  it('shows no vulnerabilities found if trace request returns an empty list', function() {
    chrome.runtime.sendMessage.yields({ traces: [] });

    try {
      getStorageVulnsAndRender({
        teamserver_url: "url",
        contrast_org_uuid: "uuid"
      });
      assert.isTrue(getStorageVulnsAndRender.calledOnce);
    } catch (e) {
      assert.isTrue(chrome.runtime.sendMessage.threw());
    }

    assert.isTrue(noVulns.style.display === 'block');
    assert.isTrue(vulnsOnPage.style.display === 'none');
    assert.isTrue(chrome.runtime.sendMessage.calledOnce);
  });

  it('shows vulnerabilities found if trace request returns a non-empty list', function() {
    let popSpy = sinon.spy(populateVulnerabilitySection);
    chrome.runtime.sendMessage.yields({ traces });

    try {
      getStorageVulnsAndRender(items);
      assert.isTrue(getStorageVulnsAndRender.calledOnce);
      assert.isTrue(popSpy.calledWith(
        traces,
        teamserver_url,
        contrast_org_uuid
      ));
    } catch (e) {
      assert.isFalse(chrome.runtime.sendMessage.threw());
    }

    assert.isTrue(noVulns.style.display === 'none');
    assert.isTrue(vulnsOnPage.style.display === 'block');
    assert.isTrue(chrome.runtime.sendMessage.calledOnce);
  });

  it('renders no vulnerabilities found on page when no short traces are returned', function() {

    let popSpy = sinon.spy(populateVulnerabilitySection);

    popSpy([], teamserver_url, contrast_org_uuid);

    assert.isTrue(popSpy.calledOnce);
    assert.isTrue(noVulns.style.display === 'block');
    assert.isTrue(vulnsOnPage.style.display === 'none');
  });

  it('can call done on promises', function(done) {
    const promise = new Promise((resolve, reject) => {
      resolve()
    })
    promise.then(() => {
      assert.ok(true)
      done();
    })
    .catch(done)
  });

  it('returns a promise that contains short vulnerabilities', function() {
    const shorts = getShortVulnerabilities(traces, teamserver_url, contrast_org_uuid);
    assert.isTrue(shorts.constructor.name === "Promise");
  });

  it('renders the short traces in the popup after receiving shortTraces', function() {

    // 1 set in beforeEach
    assert.isTrue(container.children.length === 1);

    let shortStub = sinon.stub(vulnMethods, 'getShortVulnerabilities');
    const shortTraces = [returnShortTraceData, returnShortTraceDataLowSeverity];

    shortStub.callsFake(function() {
      return new Promise((resolve, reject) => {
        resolve(shortTraces)
      });
    });

    return shortStub()
    .then(vulns => {
      vulns.map(v => renderListItem(v));
      assert.isTrue(container.children.length === 3);
    });
  });

});
