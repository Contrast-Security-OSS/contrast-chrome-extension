const chrome     = require('sinon-chrome/extensions');
global.chrome = chrome;

const URL        = require('url');
const btoa       = require('btoa');
const jsdom      = require("jsdom");
const { JSDOM }  = jsdom;
global.document = (new JSDOM(
  `<!DOCTYPE html><html><head></head><body></body></html>`
)).window.document;

const sinon      = require("sinon");
const chai       = require("chai");
const { expect, assert } = chai;
const util       = require('../../../lib/util.js');
const background = require('../../../lib/background.js');
const VulnerabilityModel = require('../../../lib/models/Vulnerability.js');
const Vulnerability = VulnerabilityModel.default;
const testData   = require("../../testData");

const APP_ID   = "webgoat-id-123";
const APP_NAME = "webgoat";
const APP_HOST = "localhost_8080";
const APP = {
  [APP_HOST]: APP_ID,
  id: APP_ID,
  name: APP_NAME,
  domain: APP_HOST,
  host: APP_HOST,
}

const APP_ID_2   = "bhima-id-123";
const APP_NAME_2 = "bhima";
const APP_HOST_2 = "localhost:3000";
const APP_2 = {
  [APP_HOST_2]: APP_ID_2,
  id: APP_ID_2,
  name: APP_NAME_2,
  domain: APP_HOST_2,
  host: APP_HOST_2,
}

let {
  STORED_APPS_KEY,
  CONTRAST_RED,
  CONTRAST_CONFIGURE_TEXT,
  CONTRAST_YELLOW,
  STORED_TRACES_KEY,
  getOrganizationVulnerabilityIds,
  generateTraceURLString,
  updateTabBadge,
} = util;

const {
  resetXHRRequests,
  notifyUserToConfigure,
} = background;

describe('tests for Vulnerability model', function() {

  let tab, badgeSpy, storeSpy, orgTracesStub, evalStub, urlSpy, vulnSpy;

  beforeEach(function() {
    global.URL = URL.URL;
    global.btoa = btoa;
    tab = { url: "http://localhost:8080/WebGoat10", id: 123 };
    badgeSpy = sinon.spy(util, 'updateTabBadge');
    storeSpy = sinon.spy(Vulnerability, 'storeTraces');
    vulnSpy = sinon.spy(Vulnerability, '_getVulnerabilityTraces');
    urlSpy  = sinon.spy(util, 'generateTraceURLString');
    orgTracesStub = sinon.stub(util, 'getOrganizationVulnerabilityIds');
    buildVulnsStub = sinon.stub(Vulnerability, 'buildVulnerabilitiesArray');
    evalStub = sinon.stub(Vulnerability, 'evaluateVulnerabilities');
    chrome.flush();
    chrome.reset();
    chrome.runtime.sendMessage.flush();
    chrome.runtime.sendMessage.reset();
    chrome.storage.local.get.flush();
    chrome.storage.local.get.reset();
    chrome.tabs.query.flush();
    chrome.tabs.query.reset();
  });

  afterEach(function() {
    chrome.flush();
    chrome.reset();
    chrome.storage.local.get.flush();
    chrome.storage.local.get.reset();
    chrome.tabs.query.flush();
    chrome.tabs.query.reset();
    orgTracesStub.restore();
    buildVulnsStub.restore();
    evalStub.restore();
    badgeSpy.restore();
    storeSpy.restore();
    vulnSpy.restore();
    urlSpy.restore();
  });

  it('sends a message to collect forms', function() {
    Vulnerability.updateVulnerabilities(tab, APP, true)
    expect(chrome.tabs.sendMessage.called).equal(true);
  });

  it('evaluates traces for vulnerabilities', function() {
    orgTracesStub.restore();
    evalStub.callsArgWith(1, testData.url, testData.traceUrls, APP, tab, false);
    evalStub(generateTraceURLString, Vulnerability._getVulnerabilityTraces);

    assert.isTrue(evalStub.called);
    assert.isTrue(vulnSpy.calledWith(
      testData.url,
      testData.traceUrls,
      APP,
      tab,
      false
    ));
  });

  it('gets vulnerabilities from teamserver using the traces', function(done) {
    buildVulnsStub.restore();
    const url = "http://localhost:8080/WebGoat/attack5a";

    orgTracesStub.resolves(testData.returnVulnerabilityIdData)

    Vulnerability._getVulnerabilityTraces(url, testData.traceUrls, APP, tab, false)

    expect(orgTracesStub.calledOnce).equal(true);
    expect(orgTracesStub.calledWith(url, APP.id)).equal(true);

    orgTracesStub(url, APP.id).then(data => {
      expect(orgTracesStub.calledTwice).equal(true);
      expect(JSON.stringify(data)).equal(JSON.stringify(testData.returnVulnerabilityIdData));
      expect(chrome.tabs.sendMessage.called).equal(true);
      expect(storeSpy.calledOnce).equal(true);
      done();
    })
    .catch(done);
  });

  // NOTE: isXHR DOES NOT PASS DOWN TO CHILD/orgTracesStub
  it('resets XHR Requests when isXHR is true', function(done) {
    buildVulnsStub.restore();
    const url = "http://localhost:8080/WebGoat/attack5a";

    orgTracesStub.resolves(testData.returnVulnerabilityIdData);

    Vulnerability._getVulnerabilityTraces(url, testData.traceUrls, APP, tab, true)

    expect(orgTracesStub.calledOnce).equal(true);

    orgTracesStub(url, APP.id).then(data => {
      const spy = sinon.spy(resetXHRRequests);

      expect(orgTracesStub.calledTwice).equal(true);
      expect(orgTracesStub.calledWith(url, APP.id)).equal(true);
      expect(JSON.stringify(data)).equal(JSON.stringify(testData.returnVulnerabilityIdData));
      expect(chrome.tabs.sendMessage.called).equal(false);
      expect(badgeSpy.called).equal(false);
      // expect(spy.called).equal(true);
      expect(storeSpy.called).equal(true);
      done();
    })
    .catch(done);
  });

  it('stores traces in chrome storage', function(done) {
    const _handleTracesStub = sinon.stub(Vulnerability, '_appendToCurrentTraces');

    buildVulnsStub.resolves(testData.returnVulnerabilityIdData);
    Vulnerability.storeTraces(testData.traceUrls, tab)
    expect(buildVulnsStub.calledOnce).equal(true);
    buildVulnsStub(testData.traceUrls).then(data => {
      expect(JSON.stringify(data)).equal(JSON.stringify(testData.returnVulnerabilityIdData));
      expect(buildVulnsStub.calledTwice).equal(true);
      expect(chrome.storage.local.get.calledWith(STORED_TRACES_KEY)).equal(true);
      expect(chrome.storage.local.get.calledOnce).equal(true);
      chrome.storage.local.get.yield();
      _handleTracesStub(chrome.storage.local.set);
      expect(_handleTracesStub.called).equal(true);
      expect(chrome.storage.local.set.calledOnce).equal(true);

      chrome.storage.local.set.yield();
      expect(chrome.storage.local.get.calledTwice).equal(true);
      chrome.storage.local.get.callsArg(1);
      chrome.storage.local.get(STORED_TRACES_KEY, badgeSpy);
      expect(badgeSpy.calledOnce).equal(true);
      done();
    })
    .catch(done);
  });
});
