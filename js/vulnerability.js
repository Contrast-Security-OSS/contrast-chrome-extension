/*global
chrome, document, $, CONTRAST_SERVICE_KEY,
TEAMSERVER_URL, CONTRAST_ORG_UUID, getOrganizationVulnerabilityesIds,
getVulnerabilityShort,
SEVERITY_NOTE,
SEVERITY_LOW,
SEVERITY_MEDIUM,
SEVERITY_HIGH,
SEVERITY_CRITICAL,
SEVERITY_NOTE_ICON_PATH,
SEVERITY_LOW_ICON_PATH,
SEVERITY_MEDIUM_ICON_PATH,
SEVERITY_HIGH_ICON_PATH,
SEVERITY_CRITICAL_ICON_PATH,
getVulnerabilityTeamserverUrl,
HTML_BODY,
CONTRAST_USERNAME,
CONTRAST_API_KEY
*/

function populateVulnerabilitySection(traces, teamserverUrl, orgUuid) {
  "use strict";
  if (traces.length > 0) {
    traces.forEach(element => {
      getVulnerabilityShort(element, () => {
        return function (e) {
          let xhr = e.currentTarget, json, trace, li;
          if (xhr.readyState === 4 && xhr.responseText !== "") {
            json = JSON.parse(xhr.responseText);
            trace = json.trace;

            li = $('<li/>')
            .addClass('list-group-item no-border vulnerability-li')
            .appendTo($("#vulnerabilities-found-on-page-list"));

            switch (trace.severity) {
              case SEVERITY_NOTE:
              li.append($('<img/>').attr("src", SEVERITY_NOTE_ICON_PATH));
              break;
              case SEVERITY_LOW:
              li.append($('<img/>').attr("src", SEVERITY_LOW_ICON_PATH));
              break;
              case SEVERITY_MEDIUM:
              li.append($('<img/>').attr("src", SEVERITY_MEDIUM_ICON_PATH));
              break;
              case SEVERITY_HIGH:
              li.append($('<img/>').attr("src", SEVERITY_HIGH_ICON_PATH));
              break;
              case SEVERITY_CRITICAL:
              li.append($('<img/>').attr("src", SEVERITY_CRITICAL_ICON_PATH));
              break;
              default:
              break;
            }

            li.append($('<h6/>').addClass('vulnerability-uuid').append(trace.uuid).hide());

            li.append($('<a/>').attr("href", "").addClass('vulnerability-rule-name').append(" " + trace.ruleName).click(event => {
              const text = $(event.target).parent().find('.vulnerability-uuid').text()
              const completeUrl = getVulnerabilityTeamserverUrl(teamserverUrl, orgUuid, text);
              chrome.tabs.create({ url: completeUrl });
            }));

          }
        };
      });

    });
  }
}

function renderVulnerability(vulnerability) {
  $("#no-results").hide();
  $("#vulnerabilities").show();
  // $("#no-vulnerabilities-found-on-page").hide();
  $("#vulnerabilities-found-on-page").show()

  li = $('<li/>')
  .addClass('list-group-item no-border vulnerability-li')
  .appendTo($("#vulnerabilities-found-on-page-list"));

  li.append($('<img/>').attr("src", SEVERITY_CRITICAL_ICON_PATH));

  li.append($('<a/>')
  .attr("href", "")
  .addClass('vulnerability-rule-name')
  .append(" " + vulnerability.label)
  .click(function (event) {
    const text = $(event.target).parent().find('.vulnerability-uuid').text()
    const completeUrl = getVulnerabilityTeamserverUrl(teamserverUrl, orgUuid, text);
    chrome.tabs.create({ url: completeUrl });
  }));
}

function getVulnerabilitiesFromTabURL(items) {
  chrome.tabs.query({ 'active': true, 'lastFocusedWindow': true }, (tabs) => {
    if (tabs[0] !== undefined) {
      const url = tabs[0].url;
      callTeamServerWithURLS(url, items)
    }
  });
}

function getVulnerabilitiesFromStorage(items) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage("getStoredTraces", (response) => {
      // console.log("getStoredTraces response", response);
      if (!!response && !!response.traces && response.traces.length > 0) {
        $("#no-vulnerabilities-found-on-page").hide();
        $("#vulnerabilities-found-on-page").show();

        populateVulnerabilitySection(response.traces, items[TEAMSERVER_URL], items[CONTRAST_ORG_UUID]);
        resolve(response.traces)
      } else {
        resolve([])
      }
    })
  })
}

function callTeamServerWithURLS(url, items) {
  getOrganizationVulnerabilityesIds(url, () => {
    return function (e) {
      const xhr = e.currentTarget
      if (xhr.readyState === 4) {

        if (xhr.status === 403 || xhr.status === 0 || xhr.responseText === "") {
          //Configuration problem
          $(HTML_BODY).addClass("configuration-problem");
          $("#no-results").show();
          $("#configuration-problem").show();
          $("#vulnerabilities").hide();
        } else {
          $("#no-results").hide();
          $("#vulnerabilities").show();
          const json = JSON.parse(xhr.responseText);
          const traces = json.traces;

          if (!traces || traces.length === 0) {
            $("#no-vulnerabilities-found-on-page").show();
            $("#vulnerabilities-found-on-page").hide();
          } else {
            $("#no-vulnerabilities-found-on-page").hide();
            $("#vulnerabilities-found-on-page").show();
            populateVulnerabilitySection(traces, items[TEAMSERVER_URL], items[CONTRAST_ORG_UUID]);
          }
        }
      }
    };
  });
}

document.addEventListener('DOMContentLoaded', () => {
  "use strict";
  chrome.storage.sync.get([
    CONTRAST_USERNAME,
    CONTRAST_SERVICE_KEY,
    TEAMSERVER_URL,
    CONTRAST_ORG_UUID,
    CONTRAST_API_KEY], (items) => {

    if (isCredentialed(items)) {
      getVulnerabilitiesFromStorage(items)
      .then(traces => {
        if (!!traces && traces.length === 0) {
          getVulnerabilitiesFromTabURL(items)
        }
      })
      .catch(error => {
        console.log("error retrieving vulnerabilities from storage");
      })
    }
  });
}, false);
