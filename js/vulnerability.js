/*global
chrome,
document,
TEAMSERVER_URL,
CONTRAST_ORG_UUID,
getVulnerabilityShort,
SEVERITY_NOTE,
SEVERITY_LOW,
SEVERITY_MEDIUM,
SEVERITY_HIGH,
SEVERITY_CRITICAL,
SEVERITY_NOTE_ICON_PATH,
SEVERITY_LOW_ICON_PATH,
SEVERITY_MEDIUM_ICON_PATH,
SEVERITY_HIGH_ICON_PATH,
SEVERITY_CRITICAL_ICON_PATH,
STORED_APPS_KEY,
SEVERITY,
getHostFromUrl,
getVulnerabilityTeamserverUrl,
getStoredCredentials,
isCredentialed,
setDisplayNone,
setDisplayBlock,
*/
"use strict";

function populateVulnerabilitySection(traces, teamserverUrl, orgUuid) {
  if (traces.length > 0) {
    Promise.all(traces.map(t => getVulnerabilityShort(t)))
    .then(shortTraces => {
      const sortedTraces = shortTraces.sort((a, b) => {
        let severityA = a.trace.severity;
        let severityB = b.trace.severity;
        return SEVERITY[severityA] < SEVERITY[severityB];
      });
      sortedTraces.map(trace => renderListItem(trace, teamserverUrl, orgUuid));
    })
    .catch(new Error("Error getting and rendering vulnerabilities"));
  } else {
    setDisplayBlock(document.getElementById("no-vulnerabilities-found"));
    setDisplayNone(document.getElementById("vulnerabilities-found-on-page"));
  }
}

function renderListItem(shortTrace, teamserverUrl, orgUuid) {
  const trace = shortTrace.trace

  if (!trace) return;

  let ul = document.getElementById('vulnerabilities-found-on-page-list');
  let li = document.createElement('li');
  li.classList.add('list-group-item');
  li.classList.add('no-border')
  li.classList.add('vulnerability-li');

  let img = document.createElement('img');

  switch (trace.severity) {
    case SEVERITY_NOTE:
      img.setAttribute("src", SEVERITY_NOTE_ICON_PATH);
      li.classList.add("vuln-5");
      break;
    case SEVERITY_LOW:
      img.setAttribute("src", SEVERITY_LOW_ICON_PATH);
      li.classList.add("vuln-4");
      break;
    case SEVERITY_MEDIUM:
      img.setAttribute("src", SEVERITY_MEDIUM_ICON_PATH);
      li.classList.add("vuln-3");
      break;
    case SEVERITY_HIGH:
      img.setAttribute("src", SEVERITY_HIGH_ICON_PATH);
      li.classList.add("vuln-2");
      break;
    case SEVERITY_CRITICAL:
      img.setAttribute("src", SEVERITY_CRITICAL_ICON_PATH);
      li.classList.add("vuln-1");
      break;
    default:
      break;
  }
  li.appendChild(img);

  // Teamserver returns camelCase vs snake_case depending on endpoint
  const ruleName = trace.ruleName || trace.rule_name;

  let anchor = document.createElement('a');
  anchor.setAttribute('href', '');
  anchor.classList.add('vulnerability-rule-name');
  anchor.innerText = " " + ruleName.split('-').join(' ').titleize();
  anchor.onclick = function() {
    chrome.tabs.create({
      url: getVulnerabilityTeamserverUrl(teamserverUrl, orgUuid, trace.uuid),
      active: false
    });
  }
  li.appendChild(anchor);

  // append li last to load content smootly (is the way it works?)
  ul.appendChild(li);
}

/**
 * getStorageVulnsAndRender - gets stored traces from background, renders the vulnerability section of the popup and sends the vulnerabilities to populateVulnerabilitySection for rendering into a list
 *
 * @param  {Object} items - credentials
 * @return {void}
 */
function getStorageVulnsAndRender(items) {
  chrome.runtime.sendMessage("getStoredTraces", (response) => {
    if (!!response && !!response.traces && response.traces.length > 0) {
      setDisplayNone(document.getElementById("no-vulnerabilities-found"));
      setDisplayBlock(document.getElementById("vulnerabilities-found-on-page"));

      populateVulnerabilitySection(response.traces, items[TEAMSERVER_URL], items[CONTRAST_ORG_UUID]);
    }
  });
}



document.addEventListener('DOMContentLoaded', () => {
  chrome.storage.local.get(STORED_APPS_KEY, (result) => {
    chrome.tabs.query({ 'active': true, 'lastFocusedWindow': true }, (tabs) => {
      if (!tabs[0]) return;

      const url  = new URL(tabs[0].url);
      const host = getHostFromUrl(url);

      if (!!result[STORED_APPS_KEY] && result[STORED_APPS_KEY].filter(app => app[host])[0]) {
        getStoredCredentials().then(items => {
          if (isCredentialed(items)) {
            getStorageVulnsAndRender(items);
          }
        });
      }
    });
  });
}, false);
