/*global
chrome,
document,
TEAMSERVER_URL,
CONTRAST_ORG_UUID,
getVulnerabilityShort,
SEVERITY_NOTE,
SEVERITY_LOW,
SEVERITY_MEDIUM,
SEVERITY_HIGH,
SEVERITY_CRITICAL,
SEVERITY_NOTE_ICON_PATH,
SEVERITY_LOW_ICON_PATH,
SEVERITY_MEDIUM_ICON_PATH,
SEVERITY_HIGH_ICON_PATH,
SEVERITY_CRITICAL_ICON_PATH,
STORED_APPS_KEY,
getHostFromUrl,
getVulnerabilityTeamserverUrl,
getStoredCredentials,
isCredentialed,
*/
"use strict";

const SEVERITY = {
  [SEVERITY_NOTE]: 0,
  [SEVERITY_LOW]: 1,
  [SEVERITY_MEDIUM]: 2,
  [SEVERITY_HIGH]: 3,
  [SEVERITY_CRITICAL]: 4,
}

function populateVulnerabilitySection(traces, teamserverUrl, orgUuid) {
  if (traces.length > 0) {
    Promise.all(traces.map(getVulnerabilityShort))
    .then(shortTraces => {
      const sortedTraces = shortTraces.sort((a, b) => {
        let severityA = a.trace.severity
        let severityB = b.trace.severity
        return SEVERITY[severityA] < SEVERITY[severityB]
      })
      sortedTraces.map(trace => {
        renderListItem(trace, teamserverUrl, orgUuid)
      })
    })
    .catch(throw new Error("Error getting and rendering vulnerabilities"))
  } else {
    document.getElementById("no-vulnerabilities-found-on-page").style.display = "block"
    document.getElementById("vulnerabilities-found-on-page").style.display = "none"
  }
}

function renderListItem(shortTrace, teamserverUrl, orgUuid) {
  const trace = shortTrace.trace

  if (!trace) return;

  let ul = document.getElementById('vulnerabilities-found-on-page-list');
  let li = document.createElement('li');
  li.classList.add('list-group-item');
  li.classList.add('no-border')
  li.classList.add('vulnerability-li');

  let img = document.createElement('img');

  switch (trace.severity) {
    case SEVERITY_NOTE:
      img.setAttribute("src", SEVERITY_NOTE_ICON_PATH);
      li.classList.add("vuln-5");
      li.appendChild(img)
      break
    case SEVERITY_LOW:
      img.setAttribute("src", SEVERITY_LOW_ICON_PATH);
      li.classList.add("vuln-4");
      li.appendChild(img)
      break
    case SEVERITY_MEDIUM:
      img.setAttribute("src", SEVERITY_MEDIUM_ICON_PATH);
      li.classList.add("vuln-3");
      li.appendChild(img)
      break
    case SEVERITY_HIGH:
      img.setAttribute("src", SEVERITY_HIGH_ICON_PATH);
      li.classList.add("vuln-2");
      li.appendChild(img)
      break
    case SEVERITY_CRITICAL:
      img.setAttribute("src", SEVERITY_CRITICAL_ICON_PATH);
      li.classList.add("vuln-1");
      li.appendChild(img)
      break
    default:
      break
  }

  let h6 = document.createElement('h6');
  h6.classList.add('vulnerability-uuid');
  h6.innerText = trace.uuid
  li.appendChild(h6);
  h6.setAttribute('style', 'display: none;');

  // Teamserver returns camelCase vs snake_case depending on endpoint
  const ruleName = trace.ruleName || trace.rule_name;

  let anchor = document.createElement('a');
  anchor.setAttribute('href', '');
  anchor.classList.add('vulnerability-rule-name');
  anchor.innerText = " " + ruleName.split('-').join(' ').titleize();
  anchor.onclick = function(event) {
    const text = li.getElementsByClassName('vulnerability-uuid')[0].innerText;
    const completeUrl = getVulnerabilityTeamserverUrl(teamserverUrl, orgUuid, text);
    chrome.tabs.create({ url: completeUrl, active: false });
  }
  li.appendChild(anchor);

  // append li last to load content smootly (is the way it works?)
  ul.appendChild(li);
}

/**
 * getStorageVulnsAndRender - gets stored traces from background, renders the vulnerability section of the popup and sends the vulnerabilities to populateVulnerabilitySection for rendering into a list
 *
 * @param  {Object} items - credentials
 * @return {void}
 */
function getStorageVulnsAndRender(items) {
  chrome.runtime.sendMessage("getStoredTraces", (response) => {
    if (!!response && !!response.traces && response.traces.length > 0) {
      document.getElementById("no-vulnerabilities-found-on-page").style.display = "none"
      document.getElementById("vulnerabilities-found-on-page").style.display = "block"

      populateVulnerabilitySection(response.traces, items[TEAMSERVER_URL], items[CONTRAST_ORG_UUID]);
    }
  });
}

document.addEventListener('DOMContentLoaded', () => {
  chrome.storage.local.get(STORED_APPS_KEY, (result) => {
    chrome.tabs.query({ 'active': true, 'lastFocusedWindow': true }, (tabs) => {
      if (!tabs[0]) return;

      const url  = new URL(tabs[0].url);
      const host = getHostFromUrl(url);

      if (!!result[STORED_APPS_KEY] && result[STORED_APPS_KEY].filter(app => app[host])[0]) {
        getStoredCredentials().then(items => {
          if (isCredentialed(items)) {
            getStorageVulnsAndRender(items);
          }
        });
      }
    });
  });
}, false);
