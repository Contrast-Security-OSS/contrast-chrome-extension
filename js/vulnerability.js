/*global
chrome,
document,
$,
TEAMSERVER_URL,
CONTRAST_ORG_UUID,
getOrganizationVulnerabilityesIds,
getVulnerabilityShort,
SEVERITY_NOTE,
SEVERITY_LOW,
SEVERITY_MEDIUM,
SEVERITY_HIGH,
SEVERITY_CRITICAL,
SEVERITY_NOTE_ICON_PATH,
SEVERITY_LOW_ICON_PATH,
SEVERITY_MEDIUM_ICON_PATH,
SEVERITY_HIGH_ICON_PATH,
SEVERITY_CRITICAL_ICON_PATH,
getVulnerabilityTeamserverUrl,
getStoredCredentials,
isCredentialed,
HTML_BODY
*/
"use strict";

function populateVulnerabilitySection(traces, teamserverUrl, orgUuid) {
  if (traces.length > 0) {
    traces.forEach((element, index) => {
      getVulnerabilityShort(element, () => {
        return (e) => {
          let xhr = e.currentTarget, json, trace, li;
          if (xhr.readyState === 4 && xhr.responseText !== "") {
            json = JSON.parse(xhr.responseText);
            trace = json.trace;

            li = $('<li/>')
            .addClass('list-group-item no-border vulnerability-li')
            .appendTo($("#vulnerabilities-found-on-page-list"));

            switch (trace.severity) {
              case SEVERITY_NOTE:
              li.addClass("vuln-5")
              li.append($('<img/>').attr("src", SEVERITY_NOTE_ICON_PATH));
              break;
              case SEVERITY_LOW:
              li.addClass("vuln-4")
              li.append($('<img/>').attr("src", SEVERITY_LOW_ICON_PATH));
              break;
              case SEVERITY_MEDIUM:
              li.addClass("vuln-3")
              li.append($('<img/>').attr("src", SEVERITY_MEDIUM_ICON_PATH));
              break;
              case SEVERITY_HIGH:
              li.addClass("vuln-2")
              li.append($('<img/>').attr("src", SEVERITY_HIGH_ICON_PATH));
              break;
              case SEVERITY_CRITICAL:
              li.addClass("vuln-1")
              li.append($('<img/>').attr("src", SEVERITY_CRITICAL_ICON_PATH));
              break;
              default:
              break;
            }

            li.append($('<h6/>')
              .addClass('vulnerability-uuid')
              .append(trace.uuid)
              .hide());

            li.append($('<a/>').attr("href", "")
              .addClass('vulnerability-rule-name')
              .append(" " + trace.ruleName)
              .click(event => {
                const text = $(event.target).parent().find('.vulnerability-uuid').text()
                const completeUrl = getVulnerabilityTeamserverUrl(teamserverUrl, orgUuid, text);
                chrome.tabs.create({ url: completeUrl, active: false });
              })
            );

            sortVulnerabilities($("#vulnerabilities-found-on-page-list"))

            // TODO: add url endpoint to li
            // console.log("json in vulnerability", json);

          }
        }
      })
    })
  }
}

function sortVulnerabilities(listElement) {
  const children = [].slice.call(listElement[0].children)
  children.sort((a, b) => {
    return a.className.match(/vuln-\d/) > b.className.match(/vuln-\d/)
  })

  // remove the children out of order and then re-add them in sorted order
  const length = children.length
  const parent = listElement[0]
  for (let i = 0; i < length; i++) {
    let detatchedItem = parent.removeChild(children[i]);
    parent.appendChild(detatchedItem);
  }
}

function getVulnerabilitiesFromTabURL(items) {
  chrome.tabs.query({ 'active': true, 'lastFocusedWindow': true }, (tabs) => {
    if (tabs[0] !== undefined) {
      const url = tabs[0].url;
      callTeamServerWithURLS(url, items)
    }
  });
}

function getVulnerabilitiesFromStorage(items) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage("getStoredTraces", (response) => {
      // console.log("getStoredTraces response", response);
      if (!!response && !!response.traces && response.traces.length > 0) {
        $("#no-vulnerabilities-found-on-page").hide();
        $("#vulnerabilities-found-on-page").show();

        populateVulnerabilitySection(response.traces, items[TEAMSERVER_URL], items[CONTRAST_ORG_UUID]);
        resolve(response.traces)
      } else {
        resolve([])
      }
    })
    reject(Error("getVulnerabilitiesFromStorage did not resolve"))
  })
}

function callTeamServerWithURLS(url, items) {
  getOrganizationVulnerabilityesIds(url, () => {
    return (e) => {
      const xhr = e.currentTarget
      if (xhr.readyState === 4) {

        if (xhr.status === 403 || xhr.status === 0 || xhr.responseText === "") {
          //Configuration problem
          $(HTML_BODY).addClass("configuration-problem");
          $("#no-results").show();
          $("#configuration-problem").show();
          $("#vulnerabilities").hide();
        } else {
          $("#no-results").hide();
          $("#vulnerabilities").show();
          const json = JSON.parse(xhr.responseText);
          const traces = json.traces;

          if (!traces || traces.length === 0) {
            $("#no-vulnerabilities-found-on-page").show();
            $("#vulnerabilities-found-on-page").hide();
          } else {
            $("#no-vulnerabilities-found-on-page").hide();
            $("#vulnerabilities-found-on-page").show();
            populateVulnerabilitySection(traces, items[TEAMSERVER_URL], items[CONTRAST_ORG_UUID]);
          }
        }
      }
    };
  });
}

document.addEventListener('DOMContentLoaded', () => {
  getStoredCredentials().then(items => {
    if (isCredentialed(items)) {
      getVulnerabilitiesFromStorage(items)
      .then(traces => {
        if (!!traces && traces.length === 0) {
          getVulnerabilitiesFromTabURL(items)
        }
      })
      .catch(error => error)
    }
  });
}, false);
