/*global
chrome,
document,
$,
TEAMSERVER_URL,
CONTRAST_ORG_UUID,
getVulnerabilityShort,
SEVERITY_NOTE,
SEVERITY_LOW,
SEVERITY_MEDIUM,
SEVERITY_HIGH,
SEVERITY_CRITICAL,
SEVERITY_NOTE_ICON_PATH,
SEVERITY_LOW_ICON_PATH,
SEVERITY_MEDIUM_ICON_PATH,
SEVERITY_HIGH_ICON_PATH,
SEVERITY_CRITICAL_ICON_PATH,
STORED_APPS_KEY,
getHostFromUrl,
getVulnerabilityTeamserverUrl,
getStoredCredentials,
isCredentialed,
*/
"use strict";

function populateVulnerabilitySection(traces, teamserverUrl, orgUuid) {
  console.log("populateVulnerabilitySection() traces", traces);
  if (traces.length > 0) {
    traces.forEach(traceUuid => {
      getVulnerabilityShort(traceUuid)
      .then(json => renderListItem(json, teamserverUrl, orgUuid));
    });
  }
}

function renderListItem(json, teamserverUrl, orgUuid) {
  const trace = json.trace;
  if (!trace) return;

  let li = $('<li/>')
  .addClass('list-group-item no-border vulnerability-li')
  .appendTo($("#vulnerabilities-found-on-page-list"));

  switch (trace.severity) {
    case SEVERITY_NOTE:
      li.addClass("vuln-5");
      li.append($('<img/>').attr("src", SEVERITY_NOTE_ICON_PATH));
      break
    case SEVERITY_LOW:
      li.addClass("vuln-4");
      li.append($('<img/>').attr("src", SEVERITY_LOW_ICON_PATH));
      break
    case SEVERITY_MEDIUM:
      li.addClass("vuln-3");
      li.append($('<img/>').attr("src", SEVERITY_MEDIUM_ICON_PATH));
      break
    case SEVERITY_HIGH:
      li.addClass("vuln-2");
      li.append($('<img/>').attr("src", SEVERITY_HIGH_ICON_PATH));
      break
    case SEVERITY_CRITICAL:
      li.addClass("vuln-1");
      li.append($('<img/>').attr("src", SEVERITY_CRITICAL_ICON_PATH));
      break
    default:
      break
  }

  li.append($('<h6/>')
    .addClass('vulnerability-uuid')
    .append(trace.uuid)
    .hide());

  // Teamserver returns camelCase vs snake_case depending on endpoint
  const ruleName = trace.ruleName || trace.rule_name;

  li.append($('<a/>').attr("href", "")
    .addClass('vulnerability-rule-name')
    .append(" " + ruleName.split('-').join(' ').titleize())
    .click(event => {
      const text = $(event.target).parent().find('.vulnerability-uuid').text()
      const completeUrl = getVulnerabilityTeamserverUrl(teamserverUrl, orgUuid, text);
      chrome.tabs.create({ url: completeUrl, active: false });
    })
  );

  sortVulnerabilities($("#vulnerabilities-found-on-page-list"));
}

/**
 * sortVulnerabilities - Sort the elements in a nested DOM Node UL by className
 *
 * @param  {Node<UL>} listElement - element containing vulnerabilities, a UL
 * @return {void}
 */
function sortVulnerabilities(listElement) {
  const children = [].slice.call(listElement[0].children);
  children.sort((a, b) => {
    return a.className.match(/vuln-\d/) > b.className.match(/vuln-\d/);
  });

  // remove the children out of order and then re-add them in sorted order
  const length = children.length;
  const parent = listElement[0];
  for (let i = 0; i < length; i++) {
    let detatchedItem = parent.removeChild(children[i]);
    parent.appendChild(detatchedItem);
  }
}

/**
 * getStorageVulnsAndRender - gets stored traces from background, renders the vulnerability section of the popup and sends the vulnerabilities to populateVulnerabilitySection for rendering into a list
 *
 * @param  {Object} items - credentials
 * @return {void}
 */
function getStorageVulnsAndRender(items) {
  chrome.runtime.sendMessage(TRACES_REQUEST, (response) => {
    if (!!response && !!response.traces && response.traces.length > 0) {
      $("#no-vulnerabilities-found-on-page").hide();
      $("#vulnerabilities-found-on-page").show();

      populateVulnerabilitySection(response.traces, items[TEAMSERVER_URL], items[CONTRAST_ORG_UUID]);
    } else {
      $("#no-vulnerabilities-found-on-page").show();
      $("#vulnerabilities-found-on-page").hide();
    }
  });
}

document.addEventListener('DOMContentLoaded', () => {
  chrome.storage.local.get(STORED_APPS_KEY, (result) => {
    chrome.tabs.query({ 'active': true, 'lastFocusedWindow': true }, (tabs) => {
      if (!tabs[0]) return;

      const url  = new URL(tabs[0].url);
      const host = getHostFromUrl(url);

      if (!!result[STORED_APPS_KEY] && result[STORED_APPS_KEY].filter(app => app[host])[0]) {
        getStoredCredentials().then(items => {
          if (isCredentialed(items)) {
            getStorageVulnsAndRender(items);
          }
        });
      }
    });
  });
}, false);
