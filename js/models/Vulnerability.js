import {
  CONTRAST_CONFIGURE_TEXT,
  CONTRAST_RED,
  CONTRAST_YELLOW,
  STORED_TRACES_KEY,
  GATHER_FORMS_ACTION,
  updateTabBadge,
  deDupeArray,
  generateTraceURLString,
  getOrganizationVulnerabilityIds,
} from '../util.js';

import {
  resetXHRRequests,
  notifyUserToConfigure,
} from '../background.js';

export default function Vulnerability(application) {
  this.application = application;
}

/**
 * updateVulnerabilities - updates the currenctly stored trace ids
 *
 * @param  {Object} tab Gives the state of the tab that was updated.
 * @return {void}
 */
Vulnerability.updateVulnerabilities = function(tab, app, credentialed) {
	// first remove old vulnerabilities since tab has updated or activated
	let evaluated = false; // used to send message only once
	if (!app) return;
	if (!evaluated) {
		chrome.tabs.sendMessage(tab.id, { action: GATHER_FORMS_ACTION }, (resp) => {

			// NOTE: An undefined reponse usually occurrs only in dev, when a user navigates to a tab after reloading the extension and doesn't refresh the page.
			if (!resp) {
				updateTabBadge(tab, "X", CONTRAST_RED);
				// NOTE: Below is possibly dangerous if !resp even after reload
				// TODO: chrome.tabs.reload(tab.id)
				// return;
			}

			evaluated = true;

      if (resp && resp.formActions && resp.formActions.length > 0) {
				const formActions = resp.formActions;
				const traceUrls 	= [tab.url].concat(formActions);
				this.evaluateVulnerabilities(credentialed, tab, traceUrls, app);
			} else {
				this.evaluateVulnerabilities(credentialed, tab, [tab.url], app);
			}
		})
	}
}

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object}  tab            Gives the state of the current tab
 * @param  {Array}   traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function(hasCredentials, tab, traceUrls, application, isXHR = false) {
	if (isXHR) {
		console.log("trace urls for evaluateVulnerabilities when isXHR", traceUrls.length);
	}

	if (hasCredentials && !!traceUrls && traceUrls.length > 0) {

		if (!application) {
      updateTabBadge(tab, CONTRAST_CONFIGURE_TEXT, CONTRAST_YELLOW);
      return null;
    }

		// generate an array of only pathnames
		const urlQueryString = generateTraceURLString(traceUrls);

		this._getVulnerabilityTraces(urlQueryString, traceUrls, application, tab, isXHR);
	} else if (hasCredentials && !!traceUrls && traceUrls.length === 0) {
		updateTabBadge(tab, "0", CONTRAST_RED);
	} else {
		notifyUserToConfigure(tab);
	}
}

Vulnerability._getVulnerabilityTraces = function(url, traceUrls, app, tab, isXHR) {
  getOrganizationVulnerabilityIds(url, app.id)
  .then(json => {
    if (!json) {
      throw new Error("Error getting json from app trace ids");
    } else if (json.traces.length === 0) {
      if (!chrome.runtime.lastError && !isXHR) {
        updateTabBadge(tab, json.traces.length.toString(), CONTRAST_RED);
      }
    } else if (!isXHR) {
      chrome.tabs.sendMessage(tab.id, {
        action: "HIGHLIGHT_VULNERABLE_FORMS",
        traceUrls,
      });
      this.storeTraces(json.traces, tab);
    }

    // isXHR is true, content script requests that XHR requests get queried for vulnerabilities
    else {
      // reset XHR global request array to empty, now accepting new requests
      resetXHRRequests();
      this.storeTraces(json.traces, tab);
    }
  })
  .catch((error) => {
    console.log(error);
    updateTabBadge(tab, "X", CONTRAST_RED);
    throw new Error("Error getting organization vulnerability ids");
  });
}

/**
 * storeTraces - locals the trace ids of found vulnerabilities to storage
 * https://blog.lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795
 * https://stackoverflow.com/a/37576787/6410635
 *
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = function(foundTraces, tab) {
		// clean the traces array of empty strings which are falsey in JS and which will be there if a trace doesn't match a given URI
		const traces = foundTraces.filter(Boolean);
    console.log("traces before buildVulnerabilitiesArray", traces);
		this.buildVulnerabilitiesArray(traces)
		.then(vulnerabilities => {
      console.log("buildVulnerabilitiesArray vulnerabilities", vulnerabilities);
			chrome.storage.local.get(STORED_TRACES_KEY, (currentTraces) => {
        console.log("currentTraces", currentTraces);
        const storedTraces = this._handleCurrentTraces(currentTraces, vulnerabilities);
        console.log("storedTraces", storedTraces);
        console.log(STORED_TRACES_KEY);
				// takes a callback with a result param but there's nothing to do with it and eslint doesn't like unused params or empty blocks
				chrome.storage.local.set(storedTraces, () => {
					chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
						// set tab badget to the length of traces in storage (can change)
						updateTabBadge(
							tab,
							result[STORED_TRACES_KEY].length.toString(),
							CONTRAST_RED
						);
					});
				});
			});
		})
		.catch(() => {
			updateTabBadge(tab, "X", CONTRAST_RED)
		});
}

Vulnerability._handleCurrentTraces = function(currentTraces, vulnerabilities) {
  let parsed = [];
  if (currentTraces[STORED_TRACES_KEY]) {
    parsed = currentTraces[STORED_TRACES_KEY];
  }

  let storedTraces = {};
  let newVulns = parsed.concat(vulnerabilities);

  return { [STORED_TRACES_KEY]: deDupeArray(newVulns) };
}

/**
 * buildVulnerabilitiesArray - builds an array of trace ids, retrieving previously stored ids and deduping
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @return {Promise} - a promise that resolves to an array of deduplicated trace ids
 */
Vulnerability.buildVulnerabilitiesArray = function(foundTraces) {
	return new Promise((resolve, reject) => {

		// first check if there are already vulnerabilities in storage
		chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
			let results;

			// results have not been set yet so just pass on foundTraces
			if (!result[STORED_TRACES_KEY] || (!!result[STORED_TRACES_KEY] && result[STORED_TRACES_KEY].length === 0)) {
				resolve(deDupeArray(foundTraces));
			} else {
				try {
					// add existing foundTraces to passed in array
					results = result[STORED_TRACES_KEY];
					results = results.concat(foundTraces);
					resolve(deDupeArray(results));
				} catch (e) {
					// if this errors then remove all the vulnerabilities from storage and start over
					this.removeVulnerabilitiesFromStorage().then(() => resolve([]));
				}
			}
			reject(new Error("Rejected buildVulnerabilitiesArray"));
		});
	});
}

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function() {
  return new Promise((resolve, reject) => {
		chrome.storage.local.remove(STORED_TRACES_KEY, () => {
			if (chrome.runtime.lastError) {
				reject(new Error(chrome.runtime.lastError));
			}

			resolve();
		});
	});
}
