import {
  CONTRAST_RED,
  STORED_TRACES_KEY,
  GATHER_FORMS_ACTION,
  getStoredCredentials,
  isCredentialed,
  updateTabBadge,
  deDupeArray,
  getHostFromUrl,
  generateURLString,
  getOrganizationVulnerabilityIds,
} from '../util.js';

import {
  getCredentials,
  resetXHRRequests,
} from '../background.js';

export default function Vulnerability(application) {
  this.application = application;
}

/**
 * updateVulnerabilities - updates the currenctly stored trace ids
 *
 * @param  {Object} tab Gives the state of the tab that was updated.
 * @return {void}
 */
Vulnerability.updateVulnerabilities = function(tab, currentApplication) {
	// first remove old vulnerabilities since tab has updated or activated
	this.removeVulnerabilitiesFromStorage(tab).then(() => {
		getStoredCredentials().then(items => {
			let evaluated = false;
			const credentialed = isCredentialed(items);
			if (!currentApplication) return;
			if (credentialed && !evaluated) {
				chrome.tabs.sendMessage(tab.id, { action: GATHER_FORMS_ACTION }, (response) => {
          console.log("GATHER_FORMS_ACTION response", response);

					// NOTE: An undefined reponse usually occurrs only in dev, when a user navigates to a tab after reloading the extension and doesn't refresh the page.
					if (!response) {
						updateTabBadge(tab, "X", CONTRAST_RED);
						// NOTE: Below is possibly dangerous if !response even after reload
						// TODO: chrome.tabs.reload(tab.id)
						// return;
					}

					evaluated = true;

          if (response && response.formActions &&
          response.formActions.length > 0) {
						const formActions = response.formActions;
						const traceUrls 	= [tab.url].concat(formActions);
						this.evaluateVulnerabilities(credentialed, tab, traceUrls, currentApplication);
					} else {
						this.evaluateVulnerabilities(credentialed, tab, [tab.url], currentApplication);
					}
				})
			} else {
				getCredentials(tab);
			}
		}).catch((error) => {
      console.log(error);
      // throw new Error("Error getting stored credentials", error);
			updateTabBadge(tab, "X", CONTRAST_RED)
		});
	}).catch((error) => {
    console.log(error);
    throw new Error("Error removing vulnerabilities from storage", error);
		updateTabBadge(tab, "X", CONTRAST_RED)
	});
	return;
}

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object} tab            Gives the state of the current tab
 * @param  {Array} traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function(hasCredentials, tab, traceUrls, application, isXHR = false) {
	if (isXHR) {
		console.log("trace urls for evaluateVulnerabilities when isXHR", traceUrls.length);
	}

	const url  = new URL(tab.url);
	const host = getHostFromUrl(url);

	if (hasCredentials && !!traceUrls && traceUrls.length > 0) {
		if (!application) return;

		// generate an array of only pathnames
		const urlQueryString = generateURLString(traceUrls);

		getOrganizationVulnerabilityIds(urlQueryString, application[host])
		.then(json => {
			if (!json) {
				throw new Error("Error getting json from application trace ids");
			} else if (json.traces.length === 0) {
				if (!chrome.runtime.lastError && !isXHR) {
					updateTabBadge(tab, json.traces.length.toString(), CONTRAST_RED);
				}
			} else if (!isXHR) {
				chrome.tabs.sendMessage(tab.id, {
					action: "HIGHLIGHT_VULNERABLE_FORMS",
					traceUrls,
				});
				this.storeTraces(json.traces, tab);
			} else {
				// reset XHR global request array to empty, now accepting new requests
				resetXHRRequests();
				this.storeTraces(json.traces, tab);
			}
		})
		.catch((error) => {
      console.log(error);
      throw new Error("Error getting organization vulnerability ids");
			updateTabBadge(tab, "X", CONTRAST_RED);
		});
	} else if (hasCredentials && !!traceUrls && traceUrls.length === 0) {
		updateTabBadge(tab, traceUrls.length.toString(), CONTRAST_RED);
	} else {
		getCredentials(tab);
	}
}

/**
 * storeTraces - locals the trace ids of found vulnerabilities to storage
 * https://blog.lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795
 * https://stackoverflow.com/a/37576787/6410635
 *
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = function(foundTraces, tab) {
		// clean the traces array of empty strings which are falsey in JS and which will be there if a trace doesn't match a given URI
		const traces = foundTraces.filter(Boolean);

		this.buildVulnerabilitiesArray(traces, tab)
		.then(vulnerabilities => {
			// storedTraces[STORED_TRACES_KEY] = JSON.stringify(vulnerabilities);

			// add tab id to VULNERABLE_TABS so that vulnerabilities can be assessed if tab is reactivated
			// if (JSON.stringify(vulnerabilities).length > 0) {
			// 	VULNERABLE_TABS.push(tab.id);
			// }
			chrome.storage.local.get(STORED_TRACES_KEY, (currentTraces) => {
				let parsed = [];
				if (currentTraces[STORED_TRACES_KEY]) {
					parsed = JSON.parse(currentTraces[STORED_TRACES_KEY]);
				}

				let storedTraces = {};
				let newVulns = parsed.concat(vulnerabilities);

				storedTraces[STORED_TRACES_KEY] = JSON.stringify(deDupeArray(newVulns));

				// takes a callback with a result param but there's nothing to do with it and eslint doesn't like unused params or empty blocks
				chrome.storage.local.set(storedTraces, () => {
					chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
						// set tab badget to the length of traces in storage (can change)
						updateTabBadge(
							tab,
							JSON.parse(result[STORED_TRACES_KEY]).length.toString(),
							CONTRAST_RED
						);
					});
				});
			});
		})
		.catch(() => {
			updateTabBadge(tab, "X", CONTRAST_RED)
		});
}

/**
 * buildVulnerabilitiesArray - builds an array of trace ids, retrieving previously stored ids and deduping
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @return {Promise} - a promise that resolves to an array of deduplicated trace ids
 */
Vulnerability.buildVulnerabilitiesArray = function(foundTraces, tab) {
	return new Promise((resolve, reject) => {

		// first check if there are already vulnerabilities in storage
		chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
			let results;

			// results have not been set yet so just pass on foundTraces
			if (!result[STORED_TRACES_KEY] || (!!result[STORED_TRACES_KEY] && JSON.parse(result[STORED_TRACES_KEY]).length === 0)) {
				resolve(deDupeArray(foundTraces));
			} else {
				try {
					// add existing foundTraces to passed in array
					results = JSON.parse(result[STORED_TRACES_KEY]);
					results = results.concat(foundTraces);
					resolve(deDupeArray(results));
				} catch (e) {
					// if this errors then remove all the vulnerabilities from storage and start over
					removeVulnerabilitiesFromStorage(tab).then(() => resolve([]));
				}
			}
			reject(new Error("Rejected buildVulnerabilitiesArray"));
		});
	});
}

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function(tab) {
  return new Promise((resolve, reject) => {
		chrome.storage.local.remove(STORED_TRACES_KEY, () => {
			if (chrome.runtime.lastError) {
				reject(new Error(chrome.runtime.lastError));
			}

			resolve();
		});
	});
}
