import {
  CONTRAST_CONFIGURE_TEXT,
  CONTRAST_RED,
  CONTRAST_YELLOW,
  CONTRAST_GREEN,
  STORED_TRACES_KEY,
  GATHER_FORMS_ACTION,
  updateTabBadge,
  deDupeArray,
  generateTraceURLString,
  getOrganizationVulnerabilityIds,
} from '../util.js';

import {
  resetXHRRequests,
  notifyUserToConfigure,
} from '../background.js';

export default function Vulnerability(application) {
  this.application = application;
}

/**
 * updateVulnerabilities - updates the currenctly stored trace ids
 *
 * @param  {Object} tab Gives the state of the tab that was updated.
 * @return {void}
 */
Vulnerability.updateVulnerabilities = function(tab, app, credentialed) {
	// first remove old vulnerabilities since tab has updated or activated
	let evaluated = false; // used to send message only once
	if (!app) return;
	if (!evaluated) {
		chrome.tabs.sendMessage(tab.id, { action: GATHER_FORMS_ACTION }, (resp) => {
      console.log("Response to gather GATHER_FORMS_ACTION send message", resp);
			// NOTE: An undefined reponse usually occurrs only in dev, when a user navigates to a tab after reloading the extension and doesn't refresh the page.
			if (!resp) {
				// updateTabBadge(tab, "X", CONTRAST_RED);
				// NOTE: Below is possibly dangerous if !resp even after reload
				// TODO: chrome.tabs.reload(tab.id)
				return;
			}

			evaluated = true;

      if (resp && resp.formActions && resp.formActions.length > 0) {
				const formActions = resp.formActions;
				const traceUrls 	= deDupeArray(formActions);
				this.evaluateVulnerabilities(credentialed, tab, traceUrls, app, false);
			} else {
				this.evaluateVulnerabilities(credentialed, tab, [], app, false);
			}
		})
	}
}

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object}  tab            Gives the state of the current tab
 * @param  {Array}   traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function(hasCredentials, tab, traceUrls, application, isXHR = false) {
	if (hasCredentials && !!traceUrls) {
		if (!application) {
      updateTabBadge(tab, CONTRAST_CONFIGURE_TEXT, CONTRAST_YELLOW);
      return null;
    }

    traceUrls.push(tab.url);
    traceUrls = deDupeArray(traceUrls);
    // generate an array of only pathnames
		const urlQueryString = generateTraceURLString(traceUrls);
		this._getVulnerabilityTraces(urlQueryString, traceUrls, application, tab, isXHR);
	} else {
		notifyUserToConfigure(tab);
	}
  return null;
}

/**
 * @description - gets trace ids from teamserver using base64 encoded query string
 * @param {String} qs - the query string of encoded urls to send to TS
 */
Vulnerability._getVulnerabilityTraces = function(qs, traceUrls, app, tab, isXHR) {
  // NOTE: URL Length Maximum - https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
  // NOTE: If qs length is 0 it will return all app trace ids
  if (qs.length > 2000 || qs.length === 0) return;
  getOrganizationVulnerabilityIds(qs, app.id)
  .then(json => {
    if (!json || !json.traces) {
      updateTabBadge(tab, '', CONTRAST_GREEN);
      throw new Error("Error getting json from app trace ids");
    }
    // else if (json.traces.length === 0 && !isXHR) {
    //   if (!chrome.runtime.lastError) {
    //     updateTabBadge(tab, json.traces.length.toString(), CONTRAST_RED);
    //   }
    // }
    else if (!isXHR) {
      chrome.tabs.sendMessage(tab.id, {
        action: "HIGHLIGHT_VULNERABLE_FORMS",
        traceUrls,
      });
      this.storeTraces(json.traces, tab);
    }

    // isXHR is true, content script requests that XHR requests get queried for vulnerabilities
    else {
      // reset XHR global request array to empty, now accepting new requests
      resetXHRRequests();
      this.storeTraces(json.traces, tab);
    }
  })
  .catch((error) => {
    console.log(error);
    updateTabBadge(tab, "X", CONTRAST_RED);
    throw new Error("Error getting organization vulnerability ids");
  });
}

/**
 * storeTraces - locals the trace ids of found vulnerabilities to storage
 * https://blog.lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795
 * https://stackoverflow.com/a/37576787/6410635
 *
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = function(foundTraces, tab) {
		// clean the traces array of empty strings which are falsey in JS and which will be there if a trace doesn't match a given URI
		const traces = foundTraces.filter(Boolean);
		this.buildVulnerabilitiesArray(traces)
		.then(vulnerabilities => {
			chrome.storage.local.get(STORED_TRACES_KEY, (currentTraces) => {
        const storedTraces = this._appendToCurrentTraces(currentTraces, vulnerabilities);
				// takes a callback with a result param but there's nothing to do with it and eslint doesn't like unused params or empty blocks
				chrome.storage.local.set(storedTraces, () => {
          console.log("set traces");
					chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
						// set tab badget to the length of traces in storage (can change)
						updateTabBadge(
							tab,
							result[STORED_TRACES_KEY].length.toString(),
							CONTRAST_RED
						);
					});
				});
			});
		})
		.catch(() => {
			updateTabBadge(tab, "X", CONTRAST_RED)
		});
}

Vulnerability._appendToCurrentTraces = function(currentTraces, vulnerabilities) {
  let parsed = [];
  if (currentTraces[STORED_TRACES_KEY]) {
    parsed = currentTraces[STORED_TRACES_KEY];
  }
  let newVulns = parsed.concat(vulnerabilities);

  return { [STORED_TRACES_KEY]: deDupeArray(newVulns) };
}

/**
 * buildVulnerabilitiesArray - builds an array of trace ids, retrieving previously stored ids and deduping
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @return {Promise} - a promise that resolves to an array of deduplicated trace ids
 */
Vulnerability.buildVulnerabilitiesArray = function(foundTraces) {
	return new Promise((resolve, reject) => {

		// first check if there are already vulnerabilities in storage
		chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
			// results have not been set yet so just pass on foundTraces
			if (!result[STORED_TRACES_KEY] || (!!result[STORED_TRACES_KEY] && result[STORED_TRACES_KEY].length === 0)) {
				resolve(deDupeArray(foundTraces));
			} else {
				try {
					// add existing foundTraces to passed in array
					let traces = result[STORED_TRACES_KEY];
					traces = traces.concat(foundTraces);
					resolve(deDupeArray(traces));
				} catch (e) {
          console.log("caught concating traces", e);
					// if this errors then remove all the vulnerabilities from storage and start over
					this.removeVulnerabilitiesFromStorage().then(() => resolve([]));
				}
			}
			reject(new Error("Rejected buildVulnerabilitiesArray"));
		});
	});
}

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function() {
  console.log("removing traces from storage");
  return new Promise((resolve, reject) => {
		chrome.storage.local.remove(STORED_TRACES_KEY, () => {
			if (chrome.runtime.lastError) {
				reject(new Error(chrome.runtime.lastError));
			}

			resolve();
		});
	});
}
