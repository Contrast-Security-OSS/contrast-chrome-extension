import {
  CONTRAST_CONFIGURE_TEXT,
  CONTRAST_RED,
  CONTRAST_YELLOW,
  CONTRAST_GREEN,
  STORED_TRACES_KEY,
  GATHER_FORMS_ACTION,
  HIGHLIGHT_VULNERABLE_FORMS,
  updateTabBadge,
  deDupeArray,
  generateTraceURLString,
  getOrganizationVulnerabilityIds,
  hasIDorUUID,
  isBlacklisted,
} from '../util.js';

import {
  resetXHRRequests,
  notifyUserToConfigure,
} from '../background.js';

export default function Vulnerability(application) {
  this.application = application;
}

/**
 * updateVulnerabilities - updates the currenctly stored trace ids
 *
 * @param  {Object} tab Gives the state of the tab that was updated.
 * @return {void}
 */
// Vulnerability.updateVulnerabilities = function(tab, app, credentialed) {
// 	// first remove old vulnerabilities since tab has updated or activated
// 	let evaluated = false; // used to send message only once
// 	if (!app) return;
// 	if (!evaluated) {
// 		chrome.tabs.sendMessage(tab.id, { action: GATHER_FORMS_ACTION }, (resp) => {
//       console.log("Response to gather GATHER_FORMS_ACTION send message", resp);
// 			// NOTE: An undefined reponse usually occurrs only in dev, when a user navigates to a tab after reloading the extension and doesn't refresh the page.
// 			if (!resp) {
// 				// updateTabBadge(tab, "X", CONTRAST_RED);
// 				// NOTE: Below is possibly dangerous if !resp even after reload
// 				// TODO: chrome.tabs.reload(tab.id)
// 				return;
// 			}
//
// 			evaluated = true;
//
//       if (resp && resp.formActions && resp.formActions.length > 0) {
// 				const formActions = resp.formActions;
// 				const traceUrls 	= deDupeArray(formActions);
// 				this.evaluateVulnerabilities(credentialed, tab, traceUrls, app, false);
// 			} else {
// 				this.evaluateVulnerabilities(credentialed, tab, [], app, false);
// 			}
// 		})
// 	}
// }

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object}  tab            Gives the state of the current tab
 * @param  {Array}   traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function(hasCredentials, tab, traceUrls, application, isXHR = false) {

  const urlQueryString = generateTraceURLString(traceUrls);

  // NOTE: URL Length Maximum - https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
  // NOTE: If urlQueryString length is 0 it will return all app trace ids
  if (urlQueryString.length > 2000 || urlQueryString.length === 0) {
    console.log("urlQueryString", urlQueryString);
    console.log("traceUrls", traceUrls);
    return;
  };
  getOrganizationVulnerabilityIds(urlQueryString, application.id)
  .then(json => {
    if (!json || !json.traces) {
      updateTabBadge(tab, '', CONTRAST_GREEN);
      throw new Error("Error getting json from app trace ids");
    }

    // chrome.tabs.sendMessage(tab.id, {
    //   action: HIGHLIGHT_VULNERABLE_FORMS,
    //   traceUrls,
    // });
    this.storeTraces(json.traces.filter(Boolean), tab, resetXHRRequests);
  })
  .catch((error) => {
    console.log(error);
    updateTabBadge(tab, "X", CONTRAST_RED);
    throw new Error("Error getting organization vulnerability ids");
  });
}

/**
 * storeTraces - locals the trace ids of found vulnerabilities to storage
 * https://blog.lavrton.com/javascript-loops-how-to-handle-async-await-6252dd3c795
 * https://stackoverflow.com/a/37576787/6410635
 *
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = function(traces, tab, resetXHRRequests) {
	// clean the traces array of empty strings which are falsey in JS and which will be there if a trace doesn't match a given URI
	this.buildVulnerabilitiesArray(traces)
	.then(vulnerabilities => {
		chrome.storage.local.set({ [STORED_TRACES_KEY]: vulnerabilities }, () => {
      console.log("set traces");
			chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
        resetXHRRequests();
				updateTabBadge(
					tab,
					result[STORED_TRACES_KEY].length.toString(),
					CONTRAST_RED
				);
			});
		});
	})
	.catch(() => {
		updateTabBadge(tab, "X", CONTRAST_RED)
	});
}

/**
 * buildVulnerabilitiesArray - builds an array of trace ids, retrieving previously stored ids and deduping
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @return {Promise} - a promise that resolves to an array of deduplicated trace ids
 */
Vulnerability.buildVulnerabilitiesArray = function(foundTraces) {
	return new Promise((resolve, reject) => {

		// first check if there are already vulnerabilities in storage
		chrome.storage.local.get(STORED_TRACES_KEY, (result) => {
      console.log("Result of get with STORED_TRACES_KEY", result);
      const storedTraces = result[STORED_TRACES_KEY];
      console.log("buildVulnerabilitiesArray storedTraces", storedTraces);
			// results have not been set yet so just pass on foundTraces
			if (!storedTraces || storedTraces.length === 0) {
				resolve(foundTraces);
			} else if (storedTraces.length > 0) {
        const traces = storedTraces.concat(foundTraces);
        resolve(deDupeArray(traces));
			} else {
        reject(new Error("Rejected buildVulnerabilitiesArray"));
      }
		});
	});
}

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function() {
  console.log("removing traces from storage");
  return new Promise((resolve, reject) => {
		chrome.storage.local.remove(STORED_TRACES_KEY, () => {
			if (chrome.runtime.lastError) {
				reject(new Error(chrome.runtime.lastError));
			}

			resolve();
		});
	});
}
