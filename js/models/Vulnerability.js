import {
  CONTRAST_CONFIGURE_TEXT,
  CONTRAST_RED,
  CONTRAST_YELLOW,
  CONTRAST_GREEN,
  STORED_TRACES_KEY,
  GATHER_FORMS_ACTION,
  HIGHLIGHT_VULNERABLE_FORMS,
  updateTabBadge,
  deDupeArray,
  generateTraceURLString,
  getOrganizationVulnerabilityIds,
  hasIDorUUID,
  isBlacklisted,
  isEmptyObject,
} from '../util.js';

import {
  resetXHRRequests,
  notifyUserToConfigure,
} from '../background.js';

import VulnerableTab from './VulnerableTab.js';

function Vulnerability() {}

// NOTE: URL Length Maximum - https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
// NOTE: If urlQueryString length is 0 it will return all app trace ids
function isTooLong(queryString, traceUrls) {
  if (queryString.length > 2000 || queryString.length === 0) {
    console.log("queryString", queryString, queryString.length);
    // console.log("traceUrls", traceUrls);
    return true;
  };
  return false;
}

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object}  tab            Gives the state of the current tab
 * @param  {Array}   traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function(hasCredentials, tab, traceUrls, application) {

  const urlQueryString = generateTraceURLString(traceUrls);
  if (isTooLong(urlQueryString, traceUrls)) return;

  console.log("URL Length was fine, received " + traceUrls.length + " traces and qs length was " + urlQueryString.length);

  getOrganizationVulnerabilityIds(urlQueryString, application.id)
  .then(json => {
    if (!json || !json.traces) {
      updateTabBadge(tab, '', CONTRAST_GREEN);
      throw new Error("Error getting json from app trace ids");
    }
    // this.highlightForms(traceUrls);
    this.storeTraces(
      json.traces.filter(Boolean),
      tab,
      application,
      resetXHRRequests
    );
  })
  .catch((error) => {
    console.log(error);
    updateTabBadge(tab, "X", CONTRAST_RED);
    throw new Error("Error getting organization vulnerability ids");
  });
}

Vulnerability.evaluateSingleURL = async function(url, tab, application) {
  const path            = (new URL(url)).pathname;
  const urlQueryString = generateTraceURLString([path]);
  const response       = await getOrganizationVulnerabilityIds(
    urlQueryString, application.id)

  console.log("evaluating single url from xhr request to", path);
  this.storeTraces( response.traces, tab, application);
}

// Vulnerability.highlightForms = function(traceUrls) {
//   // NOTE: How do we know it's the forms that are vulnerable?
//   chrome.tabs.sendMessage(tab.id, {
//     action: HIGHLIGHT_VULNERABLE_FORMS,
//     traceUrls,
//   });
// }

/**
 * storeTraces - store traces associated with a tab url
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = async function(traces, tab, application, resetXHRRequests = () => null) {
  const tabPath       = (new URL(tab.url)).pathname;
  const vulnerableTab = new VulnerableTab(tabPath, application.name, traces);
  let storedTab       = await vulnerableTab.getStoredTab();

  if (traces.length !== 0) {
    if (storedTab &&
        storedTab[vulnerableTab.id] &&
        !isEmptyObject(storedTab[vulnerableTab.id])) {
      const newTraces = storedTab[vulnerableTab.id].concat(traces);
      vulnerableTab.setTraceIDs(newTraces);
    }

    storedTab = await vulnerableTab.storeTab();
    traces    = storedTab[vulnerableTab.id];
  } else if (traces.length === 0 && vulnerableTab.traceIDs.length > 0) {
    return;
  }
  updateTabBadge(
    tab,
    storedTab[vulnerableTab.id].length.toString(),
    CONTRAST_RED
  );
  resetXHRRequests();
}

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function() {
  console.log("removing traces from storage");
  return new Promise((resolve, reject) => {
		chrome.storage.local.remove(STORED_TRACES_KEY, () => {
			if (chrome.runtime.lastError) {
				reject(new Error(chrome.runtime.lastError));
			}

			resolve();
		});
	});
}

export default Vulnerability;
