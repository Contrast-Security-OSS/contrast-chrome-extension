import {
  CONTRAST_CONFIGURE_TEXT,
  CONTRAST_RED,
  CONTRAST_YELLOW,
  CONTRAST_GREEN,
  STORED_TRACES_KEY,
  GATHER_FORMS_ACTION,
  HIGHLIGHT_VULNERABLE_FORMS,
  updateTabBadge,
  deDupeArray,
  generateTraceURLString,
  getOrganizationVulnerabilityIds,
  hasIDorUUID,
  isBlacklisted,
  isEmptyObject,
} from '../util.js';

import {
  resetXHRRequests,
  notifyUserToConfigure,
} from '../background.js';

import VulnerableTab from './VulnerableTab.js';

function Vulnerability() {}

// NOTE: URL Length Maximum - https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
// NOTE: If urlQueryString length is 0 it will return all app trace ids
function isTooLong(queryString, traceUrls) {
  if (queryString.length > 2000 || queryString.length === 0) {
    return true;
  };
  return false;
}

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object}  tab            Gives the state of the current tab
 * @param  {Array}   traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function(hasCredentials, tab, traceUrls, application, formTraces) {

  const urlQueryString = generateTraceURLString(traceUrls);
  if (isTooLong(urlQueryString, traceUrls)) return;

  console.log("URL Length was fine, received " + traceUrls.length + " urls to test and qs length was " + urlQueryString.length);

  getOrganizationVulnerabilityIds(urlQueryString, application.id)
  .then(json => {
    if (!json || !json.traces) {
      updateTabBadge(tab, '', CONTRAST_GREEN);
      throw new Error("Error getting json from app trace ids");
    }
    // this.highlightForms(traceUrls);
    this.storeTraces(
      deDupeArray(json.traces.concat(formTraces)),
      tab,
      application,
      resetXHRRequests
    );
  })
  .catch(error => {
    console.log(error);
    updateTabBadge(tab, "X", CONTRAST_RED);
    throw new Error("Error getting organization vulnerability ids");
  });
}

Vulnerability.evaluateFormActions = async function(actions, tab, application) {
  console.log("evaluating form actions");
  const paths        = actions.map(a => (new URL(a)).pathname);
  const queryStrings = paths.map(path => generateTraceURLString([path]));
  const queries      = queryStrings.map(qs => {
    return getOrganizationVulnerabilityIds(qs, application.id);
  })
  const results = await Promise.all(queries);
  return results.map((res, i) => {
    res.action = actions[i]
    return res;
  });
}

Vulnerability.evaluateSingleURL = async function(url, tab, application) {
  const path           = (new URL(url)).pathname;
  const urlQueryString = generateTraceURLString([path]);
  const response       = await getOrganizationVulnerabilityIds(
    urlQueryString, application.id)

  this.storeTraces(response.traces, tab, application);
}

Vulnerability.highlightForms = function(tab, formActions) {
  // NOTE: How do we know it's the forms that are vulnerable?
  chrome.tabs.sendMessage(tab.id, {
    action: HIGHLIGHT_VULNERABLE_FORMS,
    formActions,
  });
}

/**
 * storeTraces - store traces associated with a tab url
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = async function(traces, tab, application, resetXHRRequests = () => null) {
  const tabPath       = VulnerableTab.buildTabPath(tab.url);
  const vulnerableTab = new VulnerableTab(tabPath, application.name, traces);
  let storedTabs      = await vulnerableTab.getStoredTab();

  if (storedTabs &&
      storedTabs[vulnerableTab.vulnTabId] &&
      Array.isArray(storedTabs[vulnerableTab.vulnTabId])) {
    const newTraces = storedTabs[vulnerableTab.vulnTabId].concat(traces);
    vulnerableTab.setTraceIDs(newTraces);
  } else if (storedTabs &&
             storedTabs[vulnerableTab.vulnTabId] &&
             !Array.isArray(storedTabs[vulnerableTab.vulnTabId])) {
    throw new Error("Vulnerabilities not stored properly, should have received array.");
  }

  storedTabs = await vulnerableTab.storeTab();

  try {
    // console.log("Setting new badge count.");
    console.log(storedTabs);
    // console.log(traces);
    console.log(vulnerableTab.vulnTabId);
    // console.log(vulnerableTab);
    updateTabBadge(
      tab,
      storedTabs[vulnerableTab.vulnTabId].length.toString(),
      CONTRAST_RED
    );
  } catch (e) {
    console.log("Error setting badge in .storeTrace", e);
    console.log("STORED TABS", storedTabs);
    console.log("WITH VULN ID", storedTabs[vulnerableTab.vulnTabId]);
    console.error("Error in vulnerableTab storage structure.");
  }
  resetXHRRequests();
}

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function() {
  console.log("removing traces from storage");
  return new Promise((resolve, reject) => {
		chrome.storage.local.remove(STORED_TRACES_KEY, () => {
			if (chrome.runtime.lastError) {
				reject(new Error(chrome.runtime.lastError));
			}

			resolve();
		});
	});
}

export default Vulnerability;
