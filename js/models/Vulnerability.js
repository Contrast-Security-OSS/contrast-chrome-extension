import {
  CONTRAST_RED,
  CONTRAST_GREEN,
  STORED_TRACES_KEY,
  HIGHLIGHT_VULNERABLE_FORMS,
  updateTabBadge,
  updateExtensionIcon,
  deDupeArray,
  generateTraceURLString,
  getOrganizationVulnerabilityIds,
} from '../util.js';

import VulnerableTab from './VulnerableTab.js';

function Vulnerability() {}

// NOTE: URL Length Maximum - https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
// NOTE: If urlQueryString length is 0 it will return all app trace ids
function isTooLong(queryString) {
  if (queryString.length > 2000 || queryString.length === 0) {
    return true;
  }
  return false;
}

/**
 * evaluateVulnerabilities - method used by tab url, xhr and form actions to check TS for vulnerabilities
 *
 * @param  {Boolean} hasCredentials if the user has credentialed the extension
 * @param  {Object}  tab            Gives the state of the current tab
 * @param  {Array}   traceUrls     the urls that will be queried to TS
 * @return {void}
 */
Vulnerability.evaluateVulnerabilities = function(hasCredentials, tab, traceUrls, application, formTraces, resetXHRRequests) {

  const urlQueryString = generateTraceURLString(traceUrls);
  if (isTooLong(urlQueryString, traceUrls)) return;

  getOrganizationVulnerabilityIds(urlQueryString, application.id)
  .then(json => {
    if (!json || !json.traces) {
      updateExtensionIcon(tab, 1);
      updateTabBadge(tab, '', CONTRAST_GREEN);
      throw new Error("Error getting json from app trace ids");
    }
    // this.highlightForms(traceUrls);
    this.storeTraces(
      deDupeArray(json.traces.concat(formTraces)),
      tab,
      application,
      resetXHRRequests
    );
  })
  .catch(() => {
    updateExtensionIcon(tab, 1);
    // updateTabBadge(tab, '');
    updateTabBadge(tab, "!", CONTRAST_RED);
    throw new Error("Error getting organization vulnerability ids");
  });
}

Vulnerability.evaluateFormActions = async function(actions, tab, application) {
  if (!actions || actions.length === 0) return [];
  const paths        = actions.map(a => (new URL(a)).pathname);
  const queryStrings = paths.map(path => generateTraceURLString([path]));
  const queries      = queryStrings.map(qs => {
    return getOrganizationVulnerabilityIds(qs, application.id);
  })
  const results = await Promise.all(queries);
  return results.map((res, i) => {
    res.action = actions[i]
    return res;
  });
}

/**
 * Vulnerability - description
 *
 * @param  {type} requestURL  description
 * @param  {type} tab         description
 * @param  {type} application description
 * @returns {type}             description
 */
Vulnerability.evaluateSingleURL = async function(requestURL, tab, application) {
  const path           = (new URL(requestURL)).pathname;
  const urlQueryString = generateTraceURLString([path]);
  const response       = await getOrganizationVulnerabilityIds(
    urlQueryString, application.id);
  if (response && response.traces) {
    this.storeTraces(response.traces, tab, application);
  }
}


/**
 * @description - Send message to highlight vulnerable forms on DOM
 *
 * @param  {type} tab         description
 * @param  {type} formActions description
 * @returns {type}             description
 */
Vulnerability.highlightForms = function(tab, formActions) {
  chrome.tabs.sendMessage(tab.id, {
    action: HIGHLIGHT_VULNERABLE_FORMS,
    formActions,
  });
}

/**
 * storeTraces - store traces associated with a tab url
 *
 * @param  {Array} foundTraces - trace ids of vulnerabilities found
 * @param  {Object} tab - Gives the state of the current tab
 * @return {Promise}
 */
Vulnerability.storeTraces = async function(traces, tab, application, resetXHRRequests = null) {
  const tabPath       = VulnerableTab.buildTabPath(tab.url);
  const vulnerableTab = new VulnerableTab(tabPath, application.name, traces);
  let appTabs         = await vulnerableTab.getStoredTab();

  if (appTabs &&
      appTabs[vulnerableTab.vulnTabId] &&
      Array.isArray(appTabs[vulnerableTab.vulnTabId])) {

    const newTraces = appTabs[vulnerableTab.vulnTabId].concat(traces);
    vulnerableTab.setTraceIDs(newTraces);
  } else if (appTabs &&
             appTabs[vulnerableTab.vulnTabId] &&
             !Array.isArray(appTabs[vulnerableTab.vulnTabId])) {
    throw new Error("Vulnerabilities not stored properly, should have received array.");
  }

  appTabs = await vulnerableTab.storeTab();

  try {
    updateExtensionIcon(tab, 0);
    updateTabBadge(
      tab,
      appTabs[vulnerableTab.vulnTabId].length.toString(),
      CONTRAST_RED
    );
  } catch (e) { e }
  if (resetXHRRequests) resetXHRRequests();
}

/**
 * removeVulnerabilitiesFromStorage - removes all trace ids from storage
 *
 * @return {Promise} - returns a promise for localhronous execution
 */
Vulnerability.removeVulnerabilitiesFromStorage = function() {
  return new Promise((resolve, reject) => {
		chrome.storage.local.remove(STORED_TRACES_KEY, () => {
			if (chrome.runtime.lastError) {
				reject(new Error(chrome.runtime.lastError));
			}

			resolve();
		});
	});
}

export default Vulnerability;
